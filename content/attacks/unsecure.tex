% !TeX root = ../../thesis.tex

\section{Neither Secure Boot nor Bitlocker}
% first aim harddrive access
The first attack is performed without enabling any security mechanisms (e.g. Secure Boot, BitLocker). Our first step is to gain unrestricted access to the hard drive from the UEFI environment.
% windows uses NTFS
Since Windows uses NTFS formatting for their hard drive volumes we need to use an NTFS driver, UEFI is not required to support NTFS and as such edk2 does not come with an NTFS driver.

% search for UEFI NTFS driver with write access
% open source fork of ntfs-3g for UEFI
Luckily open source NTFS drivers are readily available such as ntfs-3g from tuxera \cite{ntfs-3g} which allow for read and write access, on top of that there already exists a port to UEFI created by pbatard \cite{ntfs-3g-uefi}.

% compile
% spits out .efi file
We can compile this driver with edk2 following the listed steps and receive a .efi file.

% try in EFI shell
% what is the EFI shell
Part of the UEFI specifications is a shell specification which is a feature rich UEFI shell application to interact with the UEFI environment.
% https://docstore.mik.ua/manuals/hp-ux/en/5991-1247B/ch04s13.html
It offers commands for
boot,
configuration,
device, driver, handle
filesystem
network
memory
scripting.
For now driver loading and filesystem navigation are of relevance.

% how to use uefi shell


we are trying in qemu where the shell is available in boot options
real hardware might require the uefi shell application .efi from the user via usb stick
explain shell screen
showing mapping, also available with map command
consistent device mapping, comparable to partition names in windows
\cite{uefi-shell}
blk and fs
load NtfsDxe.efi
drivers
map -r "reset all the default mappings in a system this option is useful if the system configuration has changed since the last boot"
new mapping and fs ontop of old blk
navigate to Windows folder
means read works
try creating folder to test write
debug why it failed
find out its from windows having hibernation enabled by default
change source code to not fallback to read only when encountering hibernation file

try to package in firmware image instead of loading from external medium
retrieve the image
for qemu we can build it ourselves
for hardware use spi clamp to  dump image

we can open image with UEFITool
an editor for firmware images conforming to the UEFI PI spec \cite{uefitool}

in UEFITool search for DXE Volume
remove previous NTFS driver if present, for full control, might be read only etc
in UEFITool search for string
since files are part of file sections we cant drop in the .efi
compile dxe driver within ovmf
generate unused volume to receive .ffs file with version, depex, user interface and pe section
add in NTFS driver .ffs file
qemu just use path to modified image
on hardware use write access with clamp

now upon opening uefi shell
we instantly see the filesystem

try to use ntfs-driver in code
this is our first rootkit iteration
payload will also be DXE driver
access to all drivers etc
package payload in firmware image
steps
read payload into RAM
search for windows installation
write payload

pack executable binary as uefi module
edk2 produces freeform image with one raw section

iterate over FirmwareVolume2 protocol instances
boottime services offer a function LocateHandleBuffer which returns all handles having a given protocol attached to them
iterate over all handles and open the protocol
call ReadSection with payload guid, to read raw section
check size match was necessary on hardware
when compiling payload a post build script generates a header for the rootkit dxe containing the size on disk for the payload

iterate over all FirmwareVolume2 Protocols
read raw section of payload file GUID into memory

iterate over all SimpleFileSystem Protocols
open volume
open file to write to
since we write into windows folder this also checks if the volume has a windows installation

achieved so far unrestricted file access
but no automatic execution nor elevated privileges

% ref to background UAC signed
dll proxying
dll hijacking
registry editing

Task Scheduler
defined in xml
cached in registry
edit with start cmd.exe and trigger manually
whoami

chntpw and reged
\cite{chntpw}
port to uefi
edit Task in machine under Control
maybe look if just adding a key would have also worked
export target registry key
modify so that registry key can differ and found via matching values
import and override registry key on target machine
payload whoami
localsystem

