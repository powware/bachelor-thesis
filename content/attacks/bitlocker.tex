\section{Bitlocker}
% https://edk2-docs.gitbook.io/edk-ii-uefi-driver-writer-s-guide/3_foundation/36_protocols_and_handles/365_tag_guid

Our final attack will be targeted against systems using BitLocker \ac{FVE} with a \ac{TPM} 2.0 an no additional PIN or startup key. This leaves the Windows boot partition encrypted, the \ac{ESP} is left unencrypted, thus not affecting the bootkit installation process. Secure Boot can be enabled in combination of BitLocker having the same effects on this attack as described in the second attack \autoref{sec:attack_secure_boot}. Due to the boot- and rootkit still sharing their core functionality we keep the approach abstract and make no further distinctions between the two. We refer to them with the expression \ac{UEFI} payload, not to be confused with our (Windows) payload that is deployed in the Windows installation.

\subsection{Infection}

For the most part of this attack we assume, that the infection is performed after BitLocker has been fully set up, only briefly touching the scenario of a user enabling BitLocker while being infected. When booting with our previous \ac{UEFI} payload, the \ac{NTFS} driver is unable to recognize any file system structure  on the Windows boot partition, due to the \ac{FVE}. Resulting in an inability to further deploy the Windows payload on the target system. Additionally, during execution of the Windows Boot Manager, the BitLocker recovery prompt, shown in \autoref{fig:bitlocker-recovery-prompt}, interrupts the regular boot process requiring the drive's recovery key for decryption before being able to continue booting.
% tpm values differ
% measured pcrs
% not unsealing vmk with tpm
This happens due to \ac{TPM} \ac{PCR} values differing from what was initially used to seal the \ac{VMK}, leaving the Windows bootloader unable to retrieve an unencrypted \ac{VMK} from the \ac{TPM} and as a result unable to decrypt the Windows installation \cite[12.]{windows-internals-7-part2}.

\begin{figure}[htb]%
    \centering
    \includegraphics[width=1.0\textwidth]{attacks/bitlocker/bitlocker_recovery_prompt.png}%
    \caption{BitLocker Recovery Prompt}%
    \label{fig:bitlocker-recovery-prompt}%
\end{figure}

In theory this is as far as we get, BitLocker in combination of \ac{TPM} measurements successfully mitigates \ac{UEFI} attacks by discovering a deviation in the boot flow.
% what is the reaction of the average user
In practice we have to ask ourselves the question how a user reacts to seeing the BitLocker recovery prompt and the consequences to the action the user takes. As an immediate reaction the user has two options: entering the recovery key into the prompt or not entering the recovery key.
% motivation behind user decision
What decision the user makes is dependent on their tech savviness and influenced by a variety of factors such as urgency of booting into Windows, knowing alternatives to what the prompt tells them.
It is reasonable to assume that the average user is willingly entering their recovery key in response to the prompt as the prompt does not suggest any malicious causes or any negative repercussions in following the instructions. The link mentioned in the prompt also only aids in locating the recovery key \cite{microsoft-recovery-key-faq}.
\TODO{mention microsofts reasons for the prompt to be triggered}
\TODO{what is the actual alternative}
% does the user trust the system
% why would they not trust the system
% (ask admin for recovery password)
% type in recovery password
% alternative would be to remove drive and insert into safe device



\subsection{Approach}

Even when assuming that the user enters their recovery key, we are still unable to access the Windows installation, as BitLocker never ldoes not en/decrypt the hard drive as a whole upon boot but instead performs these respective action when reading or writing a block of data to or from the hard drive.

What we can do is try to record the keystrokes performed by the user while entering their recovery key and use it at some later point to gain control over the hard drive. A program designed to perform this type of attack is called a keylogger.

To implement such a keylogger we have to alter the code execution that happens when the recovery prompt is shown. For this our first step is to find our what execution environment or \ac{UEFI} stage we are in, is Windows already using separate drivers for keyboard access or still relying on the \ac{UEFI} environment and its protocols.

% ref to background os loader
% prompt is done by the OS Loader
% ergo still during transient system load phase
% required to use protocol services
% therefor uses uefi services for IO
% such as SimpleTextInputEx Protocol
% go over the two different input protocols
% find out which one is used
The \ac{UEFI} specification defines two protocols which are used to abstract keyboard input these are the \lstinline{{SimpleTextInputProtocol} and the \lstinline{{SimpleTextInputExProtocol} \cite[12.2, 12.3]{uefi-spec}. To figure out if the recovery prompt uses these to read key strokes we can just add some print statements to the \lstinline{ReadKeyStroke} and \lstinline{ReadKeyStrokeEx} functions of their implementations in the \ac{EDK} II \ac{OVMF} package. On the next boot when typing we find that our \lstinline{ReadKeyStrokeEx} print statements from the \lstinline{{SimpleTextInputExProtocol} are triggered.

Now, knowing that the BitLocker recovery prompt is shown by an application running in the \ac{UEFI} boot environment, we can leverage this environment to implement our keylogger.

% explain more in depth how protocols are returned to the end user
% one instance per controller/handle
\TODO{how are protocols returned to the end user}
% explain basic back to the caller. This method is called function hooking
% explain how we retain information of the hook in question
% map protocol pointer to hook information
% keylog recovery key
To alter the code execution when performing a key stroke we can just iterate over all instances of the \lstinline{{SimpleTextInputExProtocol} and reassign the \lstinline{ReadKeyStrokeEx} entry of the struct, which is a function pointer. We will save each protocol instances' original function address and instead have it point to an intermediary function. This intermediary calls the original function and performs logging of the key stroke result before relaying the result to the caller. This method is called function hooking and is intransparent to consumer of a protocol.

%  show whole protocol
% WaitForKeyEx event
% wait for event
% query which key it was

\TODO{how is the SimpleTextInputEx Protocol used}

So far we are able to track each keystroke that queried via the \lstinline{ReadKeyStrokeEx} function, which in our testing is only done during the recovery prompt, but may be used by the interactive boot menu.

The BitLocker recovery prompt does not allow the user to input any
\TODO{key input advancement is weird and makes tracking tricky}
F keys
block validity
only divisable by 11
\cite[9. BitLocker Key Recovery]{windows-internals-6-part2}
cursor can move out of incomplete or valid blocks
up and down increments or decrements the cursor position

alternatively screen shot
still need hook to find when enter is pressed
explain how screenshotting works
some basic compression
wait for recovery key
send recovery key on enter press

on real hardware
network stack wasn't installed onto handles when boot over ip was disabled
compared loaded dxe drivers between both configurations with efi shell
Realtek Family driver not loaded
load manually
reinstall all handle to controllers to enable network stack regardless

sending key out is only good for physical access attack vector
dislocker linux utility
\cite{dislocker}
mount encrypted drive with decryption mean
read and write access
dual boot in vm
enter recovery key and it works
port to\ac{UEFI}

bitlocker encrypts block-wise

% blk and fs
\TODO{explain block devices}
\TODO{explain file system independent abstraction better}
\ac{UEFI} protocol stack
\TODO{diagram of block io, disk io, simple file system and file protocol interaction (with hindsight of adding dislocker beneath block io)}
\cite[13.3.2 Partition Disocvery]{uefi-spec}
Drivers providing \emph{Simple File System Protocol} use the \emph{Block I/O Protocol} to access the underlying media.


hook block io
again hook data mapping

% execute after NTFS driver by doing it in an ExitBootServices hook
It is beneficial for us to write our payload to the Windows installation as close to the end of the \ac{UEFI} environment as possible, this will maximize the presence of drivers and their offered access to hardware devices. It is also a wise design decision for the attacks following to this one. The call of the function \lstinline{ExitBootServices} marks the point of transitioning from boot time to runtime where the operating system takes over the control of the system, it presents a good opportunity for us to perform the write action of our rootkit.
% was muss man beachten bei exitbootservices hooking
\cite{exitbootservices-hooking}
hook ExitBootServices
enable hook
write payload
import registry key
disable hook

next boot would require to recovery key again
% https://learn.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-use-bitlocker-drive-encryption-tools-to-manage-bitlocker
update tpm values in payload
\cite{microsoft-bitlocker-manage-bde}
caveat pin? look into this


\subsubsection{BitLocker post Infection}
% reference to rootkit definition
persistence when part of root of trust
fresh install / tpm update values
% paper von betreuern
hook \ac{TCG2} Protocol \cite[6.7.3]{tcg-efi-protocol-spec}
\ac{TPM} communication
% \cite[12.7 TPM_Unseal]{tcg-tpm-library-part3-commands}
receive bitlocker \ac{VMK} key and send to dislocker
\cite{bde-format-spec}
\cite{tpm-sniffing}

% https://labs.withsecure.com/publications/sniff-there-leaks-my-bitlocker-key