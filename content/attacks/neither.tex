% !TeX root = ../../thesis.tex

\section{Neither Secure Boot nor Bitlocker}

% premise of attack
Our first attack is performed on a system without Secure Boot or BitLocker enabled.
% general concept
% deviate the boot flow
% access to the hard drive from the UEFI Environment
% deploy payload so that it is executed
We implement a bootkit and a rootkit, that deviate the regular boot flow to access the Windows installation and deploy a payload that is automatically executed upon Windows boot.

\subsection{Bootkit}

\subsubsection{Infection}

% https://stackoverflow.com/questions/40208794/findfirstvolume-does-not-return-efi-system-partition
% https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntopenfile?redirectedfrom=MSDN

We have two ways to infect a system, we can either use a bootable USB stick with a UEFI application installing the bootkit or a Windows executable mounting the \ac{ESP} with admin privileges.
The installation process is identical for both options, we access the \ac{ESP} and create a copy of the Windows Boot Manager located under \lstinline{EFI\\Microsoft\\Boot\\bootmgfw.efi}. We then replace the original with our bootkit as well as drop all resources required by the bootkit on the \ac{ESP}.

\subsubsection{Approach}

\TODO{dump a windows boot entry}
Now that our bootkit is in place of the Windows Boot Manager, when the \ac{UEFI} Boot Manager selects the boot load option \lstinline{Boot####} for the Windows Boot Manager, the file path \lstinline{EFI\\Microsoft\\Boot\\bootmgfw.efi} will cause our bootkit to be executed.
% UEFI does not support NTFS
For our storage-based approach we now need to access the Windows installation from within the \ac{UEFI} environment to deploy our payload. We want to access the \ac{NTFS} formatted Windows boot partition, this requires an additional \ac{NTFS} driver due to the \ac{UEFI} specification only mandating compliant firmware to support FAT12, FAT16 and FAT32 \cite[13.3.1.1]{uefi-spec}. The \ac{EDK} II reference implementation does not provide an \ac{NTFS} driver either.
% search for UEFI NTFS driver with write access
% open source fork of ntfs-3g for UEFI
We can use a fork of the open source \ac{NTFS} driver \lstinline{ntfs-3g} from Tuxera \cite{ntfs-3g}, that was ported to the \ac{UEFI} environment by \emph{pbatard} \cite{ntfs-3g-uefi}.

% compile
% spits out .efi file
We can compile this driver with \ac{EDK} II to receive a \lstinline{.efi} executable file.

% try in EFI shell
% what is the EFI shell
\TODO{better summary of UEFI shell}
Part of the family of \ac{UEFI} specifications is a shell specification which defines a feature rich \ac{UEFI} shell application to interact with the \ac{UEFI} environment \cite[1.1]{uefi-shell-spec}. It offers commands related to boot and general configuration, device and driver management, file system access, networking \cite[5.1]{uefi-shell-spec} and supports scripting \cite[4]{uefi-shell-spec}. We can use the file system related commands to test the \ac{NTFS} driver.
\autoref{fig:uefi-shell} depicts an exemplary output of an EDK II UEFI shell emulated under QEMU.

% how to use uefi shell
% we are trying in qemu where the shell is available in boot options
% real hardware might require the uefi shell application .efi from the user via usb stick
The \ac{UEFI} shell may already be part of the boot options but can always be supplied on a \ac{USB} stick in the default boot path.

% explain shell screen
Upon invocation, the shell application performs an initialization during which it \TODO{does what? whats important for us here} and produces output what is equivalent to the output of the execution of the commands \lstinline{ver} and \lstinline{map -terse} \cite[3.3 Initialization]{uefi-shell-spec}. \lstinline{ver} displays the version of the \ac{UEFI} specification the firmware conforms to \cite[5.3 Shell Commands]{uefi-shell-spec}.

\includegraphics[width=\textwidth]{attacks/neither/01_uefi_shell.png}


% showing mapping, also available with map command
% consistent device mapping, comparable to partition names in windows
The map command is very interesting for file access with the shell, it displays a mapping table between user defined alias names and device handles. The aliases can be used instead of a device path when submitting commands via the command line interface. The \ac{UEFI} shell also produces default mappings, notably for file systems \cite[3.7.2. Mappings]{uefi-shell-spec}. These mappings are designed to be consistent across reboots as long as the hardware configuration stays the same, they are comparable to Windows partition letters \cite[Appendix A]{uefi-shell-spec}.

\TODO{find in spec what precise mapping mechanism}
When we inspect the mapping table we can see \lstinline{FSx:} and \lstinline{BLKx:} aliases, \lstinline{FSx:} maps to file systems and \lstinline{BLKx:} to block devices. This identification is performed via instances of the \emph{Simple File System Protocol} and \TODO{double check} Block I/O Protocol.
% explain Simple File System Protocol
The \emph{Simple File System Protocol} \cite[13.4 Simple File System Protocol]{uefi-spec} provides, together with the File Protocol, file-type access to the device it is installed on \cite[13.5 File Protocol]{uefi-spec}. The two protocols are independent of the underlying file system the media is formatted with.


% load NtfsDxe.efi
Our \ac{NTFS} \ac{UEFI} Driver is one such abstraction and needs to be loaded, this is done by first entering the alias, for the file system containing the \lstinline{NtfsDxe.efi}.
This effectively switches the console's working directory to be the root of the entered file system, now we can invoke \lstinline{load} with the path to the executable. The output indicates whether loading the driver was successful.
% drivers
% We can now list
With the command drivers, we can list all currently loaded drivers and some basic information about them, such as number of devices managed. We can see that the NTFS driver already manages devices.

% map -r "reset all the default mappings in a system this option is useful if the system configuration has changed since the last boot"
% new mapping and fs ontop of old blk
We can now reset all default mappings with the map -r command to receive an updated list including the file systems now provided by the \ac{NTFS} driver. The mapping also shows us that the file system now sits on top of a device which previously was only listed as a block device.

As done before we now type the alias of the new file system to switch to NTFS formatted file system. With \lstinline{ls} we can list the current directory's content and confirm by the presence of the Windows folder that we are on the volume containing the Windows installation.
\TODO{maybe vol} % With \lstinline{vol} we can query information about the current volume, this shows us that our d


% navigate to Windows folder
% means read works
% try creating folder to test write
\TODO{Windows file access privileges}
We now navigate into the Windows folder to test whether we have unrestricted read and write access, since is not the case if done by an unprivileged user when performed from within Windows. Accessing folders and viewing their contents is possible but creation of a new folder fails.

% debug why it failed
% find out its from windows having hibernation enabled by default
% change source code to not fallback to read only when encountering hibernation file
Upon debugging the \ac{NTFS} driver it appears to be that the drivers falls back to read only when it encounters a file that indicates that the Windows system is in hibernation mode. Windows seems to have hibernation enabled by default and as such our rootkit should not rely on it being disabled, we can change the code of the \ac{NTFS} driver to not fallback when encountering this file.

We now know that provided we get to load the \ac{NTFS} driver we can access a Windows installation and subsequently the entire data of unencrypted hard drives. Since our rootkit will not use the UEFI shell we need to have the NTFS driver load as part of the boot process.

% try to use ntfs-driver in code
% this is our first rootkit iteration
% payload will also be DXE driver
% package payload in firmware image
The next step is for our bootkit to use the NTFS driver to gain file system access and write our payload to the Windows installation. During our bootkit infection process we place the NTFS driver on the \ac{ESP}, so that our bootkit can load it. In our bootkit, we can use the Loaded Image Protocol, that is installed to the handle of the bootkit's image in memory to retrieve the handle of the device our bootkit was loaded from \cite[9.1 EFI Loaded Image Protocol]{uefi-spec}. This handle can then be used to call the Boot Services \lstinline{LoadImage} and \lstinline{StartImage} to load and execute the NTFS driver. Since the driver conforms to the UEFI Driver Model, we need to also reconnect all controllers recursively, so it can assume controller over the NTFS formatted volumes, by installing the \emph{Simple File System Protocol} on their handles. Loading the payload and other non-executable files into memory is done differently, here we use the handle from the Loaded Image Protocol to open the \emph{Simple File System Protocol} installed onto the \ac{ESP}, we can then call the \lstinline{OpenVolume} resulting in an instance of the File Protocol representing the root folder of the volume \cite[13.4]{uefi-spec}. This instance can then be used to open and read our payload with the absolute path on the \ac{ESP} into memory.
% write payload
% seems to not be needed: install tag protocol on NTFS driver and put into depex of rootkit
% search for windows installation
% iterate over all \emph{Simple File System Protocol} instance
% open volume
To perform the write operation we now need a handle we did not yet interact with, at least directly. We can use the Boot Service \lstinline{LocateHandleBuffer} to receive an array of all handles that support the \emph{Simple File System Protocol}, this includes volumes such as the \ac{ESP} but also the Windows recovery partition. We can iterate over all handles to open the volume and attempting to create a new file with a file path that's inside of the Windows installation. This operation fails on volumes not containing a Windows installation which we can just skip. Eventually the volume containing Windows is found and the file is created and opened successfully, we can then write our payload, that we read into memory earlier, onto the disk and close the file again.

Now the question arises as to where to write our payload to, we want automatic and elevated execution. Earlier we discovered that the \ac{NTFS} \ac{DXE} driver disregards the file access permission model \TODO{Windows File Permissions} so we are not restricted in the same way an unprivileged user would be when accessing the disk. \emph{MosaicRegressor} writes its payload to the Windows startup folder, a folder whose contents are automatically executed at system startup. The programs within the startup folder are unfortunately not automatically run at an elevated level, so this isn't a suitable target location.

\TODO{DLL proxy loading}
\TODO{modifying Windows Executables KMCI}

% Task Scheduler
The Task Scheduler is a Windows service responsible for managing the automatic execution of background tasks \cite[10. The Task Scheduler]{windows-internals-7-part2}. Tasks are performed on certain triggers, which may be time-based (periodically or on a specific time) or event-based, for example on user logon or system boot\cite{microsoft-task-scheduler-triggers}. A task can perform various actions upon invocation \cite{microsoft-task-scheduler-actions}, but we will focus on command execution. Most tasks will simply execute other programs as their action, this execution is performed under specified a security context \cite{microsoft-task-scheduler-security-contexts}. The idea of our attack is to have a task, that performs its action with a high privelege level, execute our payload. The task of our choosing is called \lstinline{Autochk\Proxy}, that performs the command

\begin{lstlisting}
%windir%\system32\rundll32.exe /d acproxy.dll,PerformAutochkOperations
\end{lstlisting}

30 minutes after system boot, the executable \lstinline{rundll32.exe} loads the \ac{DLL} \lstinline{acproxy.dll} and invokes the exported function \lstinline{PerformAutochkOperations} \cite{microsoft-rundll32}. The function name as well as the task name suggest the performed action relates to the Windows utility \emph{autochk} which verifies the integrity of \ac{NTFS} file systems \cite{microsoft-autochk}. The Task Scheduler keeps book of its active tasks in the registry under \lstinline{HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache}, grouped by four subkeys Boot, logon, plain and Maintenance. These entries consist only of a \ac{GUID} that is used to look up the task descriptor saved under their respective task master (registry) keys, these task master keys are located under \lstinline{HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks} \cite[10. The Task Scheduler - Initialization]{windows-internals-7-part2}. There also exist a secondary copy of the task descriptors, on the regular file system under \lstinline{%windir%\system32\Task}, stored as \ac{XML} files.

We can use the Task Scheduler Configuration Tool to modify the target task on a system under our control, we change the executable path as well as remove the configured delay. We then use the Windows registry editor \lstinline{reged.exe} to navigate to the task descriptor store, there we search for the task master key belonging to our task and export this key.

\includegraphics[width=\textwidth]{attacks/neither/05_taskscheduler_autochk.png}

% edit with start cmd.exe and trigger manually
% whoami
% We modify the task's action, to run our payload instead. To verify the privileges our payload is executed with, we can save the output of \lstinline{whoami /all} into a file. The \lstinline{whoami} command shows the current user and privileges \cite{microsoft-whoami}. After manually triggering the task through the configuration tool, we see that our payload was run from the \lstinline{nt authority\system} user account, which is the most privileged system account \cite{microsoft-localsystem-account}.

% \TODO{whoami /all snippet}

% chntpw and reged
% edit Task in machine under Control
We can use this exported key and import it on our victim's system as part of our attack. To import the key on an offline system, we can use a Linux utility called \lstinline{chntpw} whose primary purpose it is to reset the password of local windows user accounts \cite{chntpw}. The library does this by editing the registry of a Windows installation and as such the author also offers a standalone registry editor called \lstinline{reged}.
% test
% dual boot
We can test the Linux tool when dual-booting a Linux and a Windows installation. We place our payload in the Windows installation and then boot into Linux, where we can open the \lstinline{HKEY_LOCAL_MACHINE/SOFTWARE} hive in \lstinline{reged} and import our modified registry key.
% import and override registry key on target machine
This overrides the task descriptor and when booting into Windows our payload is executed.

% port to uefi
The next step is to port the \lstinline{reged} utility so that it works in the UEFI environment, so we can use it as part of our bootkit.
% most stdlib stuff is just mapping to UEFIlib stuff with equivalents or using gcc implementations
The porting process boils down to providing semantically equivalent definitions of external function calls, such as c standard library and Linux kernel functions, to link against. Declarations and macros are still supplied by the local compiler's system headers. Function definitions can often be translated to \ac{UEFI} equivalents, \ac{EDK} II has libraries offering implementations of commonly used abstraction.
% memory allocation (malloc, calloc, realloc), memory manipulation (memset, memcpy) string manipulation (sscanf, strtol), stdout (printf), abort, exit
Memory allocation maps to the MemoryAllocationLib, memory manipulation to BaseMemoryLib, basic string manipulation to BaseLib, stdout to PrintLib (only relevant for print debugging).
% cstdio is non trivial and has to be implemented by calling protocols on the right volume
Function calls related to standard input and output such as opening, reading and writing a file, namely the hive file, are more complex and have to be mapped to the \ac{UEFI} protocols \emph{Simple File System Protocol} and \emph{File Protocol}. Luckily the author of \lstinline{reged} used distinct functions to access the hive file and registry file, making it possible to keep the original source code unmodified.
% modify so that registry key can differ and found via matching values
Except for a change in the import behavior. The name of a task master key is the task's \ac{GUID}, which may differ from device to device, thus we cannot import a key into its exact path, we instead iterate over the subkeys of the target's parent key. We then match for the name value of the key.

Now that we modified the Windows installation to execute our payload upon boot, we need to transfer execution from the bootkit to the original Windows Boot Manager. Loading the original application is inspired by how the UEFI Boot Manger loads boot options, this includes relaying the \lstinline{LoadOptions} and \lstinline{ParentHandle} of the \emph{\ac{EFI} Loaded Image Protocol} \cite[9.1]{uefi-spec} instance installed to our bootkit to the Windows Boot Manager.


\subsection{Rootkit}

Performing the same attack in the form of a rootkit is very similar. The \ac{UEFI} payload is now compiled as a \ac{DXE} driver instead of an application, so that it is loaded when the \ac{DXE} Dispatcher iterates over the \ac{FV} it is contained within.

\subsubsection{Infection}


retrieve current firmware image
modify image by adding our DXE drivers to the DXE volume
rewrite the image

% for hardware use spi clamp to  dump image
For this, we have to read out the firmware image, modify the contents and write the new image back to hardware. This can be done by using a spi flash programmer and clamping the physical chip. Or using an SPI chip emulator. \TODO{properly list the options}
% for qemu we can build it ourselves
If we want to use emulation we can build the Open Virtual Machine Firmware (OVMF) Package from EDK II which is a firmware image for virtual machines.

% we can open image with UEFITool
Now that we have the image we can edit it with UEFITool, which is an editor for firmware images conforming to the UEFI PI spec \cite{uefitool}.
In UEFITool we navigate to the DXE Volume containing the DXE Core and DXE drivers.

% remove previous NTFS driver if present, for full control, might be read only etc
% in UEFITool search for string
Before adding our driver we remove any other NTFS driver packed in the image by OEMs, because they might be read-only or otherwise restricted and would inhibit our NTFS driver from installing onto a device, if it were to load earlier. UEFITool offers a search through the entire firmware image. We can search for "NTFS" as a case-insensitive string, since most drivers either have a User Interface Section which contains a human-readable name for inspection tools like UEFITool \cite[Vol 3, 3.2.5]{pi-spec} or support the optional Component Name Protocol which is part of the UEFI Driver Model and returns the name of a driver \cite[11.5]{uefi-spec}. If this would not suffice it is possible to search for the NTFS magic number indicating that a volume is formatted with NTFS, this number is ASCII encoded NTFS followed by four white spaces and likely contained by an NTFS driver.

% since files are part of file sections we cant drop in the .efi
If we now want to add our NTFS driver .efi file with UEFITool we cannot do this directly, because DXE drivers have three mandatory sections: PE32 executable, version and DEPEX section \cite[Vol 3, 2.1.4.1.4]{pi-spec} and these are not automatically generated.

% compile dxe driver within ovmf
% generate unused volume to receive .ffs file with version, depex, user interface and pe section
For these files to be generated it is easiest to simply build the \ac{NTFS} driver as part of the \ac{EDK} II \ac{OVMF} and have it packaged in a firmware volume. This can be an unused volume or for debugging purposes the \ac{DXE} volume, for real hardware we can use the output of the build process which is a \lstinline{.ffs} file. The \lstinline{.ffs} file contains the \ac{PE32}, version, \ac{DEPEX} and an optional user interface section.

% pack executable binary as uefi module
% EDK II produces freeform image with one raw section
For the rootkit to write a payload to disk it needs to know what to write, we can create an \ac{EDK} II module with a Windows targeted executable and have it packaged as a binary, this produces a \lstinline{.ffs} file of type \lstinline{EFI_FV_FILETYPE_FREEFORM}, which puts no restrictions on the contained file sections \cite[Vol 3, 2.1.4.1.7]{pi-spec}. The output contains only one file section of type \lstinline{EFI_SECTION_RAW} which contains the binary payload.

% add in NTFS driver .ffs file
% on hardware use write access with clamp
% qemu just use path to modified image
We can now simply insert the .ffs file into the target firmware image with UEFITool.

overwrite the SPI flash with modified image by using the programmer again.

\subsubsection{Approach}

% read payload into RAM
% iterate over FirmwareVolume2 protocol instances
% boottime services offer a function LocateHandleBuffer which returns all handles having a given protocol attached to them
% iterate over all handles and open the protocol
% call ReadSection with payload guid, to read raw section
% check size match was necessary on hardware
% when compiling payload a post build script generates a header for the rootkit dxe containing the size on disk for the payload
When the rootkit is executed it starts by reading the payload into memory, this is done by calling the boot service function \lstinline{LocateHandleBuffer} with the option \lstinline{ByProtocol} and the \ac{GUID} for \lstinline{gEfiFirmwareVolume2ProtocolGuid} which returns all handles that have a protocol instance associated with \lstinline{gEfiFirmwareVolume2ProtocolGuid} installed onto them \cite[7.3]{uefi-spec}. We can now iterate over all protocol instances, open the protocol and query the firmware volume for the \ac{GUID} of our binary payload, we then read the content of the raw section into a buffer. \TODO{maybe size match on hardware}

payload has to also reside in the firmware image, EDK II binary module

different protocol to load the payload

we dont have to load the other drivers now as this is done by the DXE Dispatcher

we dont have to load the windows boot manager as this is still done by the UEFI Boot Manager