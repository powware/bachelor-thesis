% !TEX root = ../thesis.tex

\chapter{Background}

The following introduces the background information necessary to understand the employment of a \ac{UEFI} rootkit. This includes the general workings of the \acf{PI} and \ac{UEFI}, the \ac{UEFI} programming model and interface itself; as well as its security mechanisms. It is also necessary to understand our target's defenses, for this, we briefly describe the Window's security mechanisms faced when performing our attacks.

\section{\acs{UEFI}}

% what is it
\acf{UEFI} is a specification that defines an abstract interface between an \acf{OS} and the \acf{PF}.
% why does it exist
It was designed to replace the legacy \acl{BF} \ac{BIOS}, while also often offering a backwards compatible mode with the \acf{CSM}.
% what it defines
The specification is a pure interface specification thus merely states what interfaces and structures a \ac{PF} has to offer and what an \ac{OS} may use.
% what it doesn't define
how it is implemented by PF
what is used by OS
% what does it consist of
boot- and runttime service functions for the bootloader and os to call
datatables containing platform-related information
% what are its concrete goals
- complete solution describing all features and capabilities
- abstract interfaces to support a range of processors without the need for knowledge about underlying hardware for the bootloader
- sharable persistent storage for platform support code
security

\subsection{Boot Sequence}

focus will be on dxe and transient system load

\begin{enumerate}
    \item{\acf{SEC}}

    establishment of root of trust in the system
    inductive security design
    integrity of subsequent module is checked by the previous module
    first module is root of trust
    %ref to PSP

    handles all platform restart events
    applying power to system from unpowered state
    restarting from active state
    receiving exception conditions

    creates temporary memory store
    possibly CPU \ac{CAR}
    cache behaves as linear store of memory
    no evictions mode
    every memory access is a hit
    eviction not supported as main memory is not set up yet and would lead to platform failure


    final step
    Pass handoff information to the \ac{PEI} Foundation
    % what is the PEI foundation
    \begin{itemize}
        \item state of platform
        \item location and size of the \ac{BFV}
        \item location and size of the temporary RAM
        \item location and size of the stack
        \item optionally one or more \acp{HOB} via the \ac{SEC} \ac{HOB} Data \ac{PPI}
    \end{itemize}

    SEC Platform Information PPI
    information about the health of the processor

    SEC HOB Data PPI

    \item{\acf{PEI}}

    initialize stuff

    \item{\acf{DXE}}

    dxe core
    dxe dispatcher
    depex
    dxe drivers

    \item{\acf{BDS}}


    \item{\acf{TSL}}

    boottime and runtime services/driver
    bootloader
    ExitBootServices()

    \item{\acf{RT}}

    runtime services/driver

    \item{\acf{AL}}

    hibernation
    sleep

\end{enumerate}

\subsection{\acs{UEFI}/\acs{PI} Firmware Images}

flash device
flash volume
flash file system
file sections
depex

\subsection{\acs{UEFI} Images}

executable
subset of PE32+ file format with modified header signature to distinguish from normal PE32 Images
+ stands addition of 64-bit relocation fix-up extension
fixed and dynamic address loading
relocatable
boot and runtime memory
application vs os loader vs driver
loaded fully into memory and reloaction fix ups
memory marked as code and data
jump to entry point
what is the boot manager

\subsubsection{\acs{UEFI} Applications}

example efi shell
loaded by boot manager or other applications
return or calling exit specifically
always unloaded from memory

\subsubsection{UEFI OS Loaders}

example windows boot manager
normally take over control from the firmware
upon load behaves like a normal UEFI application
- only use memory allocated from the firmware
- only use services/protocols to access devices that the firmware exposes
- conform to driver specifications to access hardware
on error can return allocated resources with Exit boot service with error specific information given in ExitData
on success take full control with ExitBootServices boot service
all boot services in the system are terminated, including memory management
UEFI OS loader now responsible

\subsubsection{UEFI Drivers}

loaded by boot manager, UEFI firmware (DXE foundation), or other applications
example payload
unloaded only when returning error code
presistent on success
boot and runtime drivers
only difference is that runtime are available after ExitBootServices was called
boottime drivers are terminated and memory is released
runttime drivers are fixed up with virtual mappings upon SetVirtualAddressMap call
has to convert its allocated memory

\subsection{Firmware Core}

boot and runtime services
boot service table
guids
handles and protocols
protocols

\subsection{edk2}
build system

\subsection{Security}
% https://edk2-docs.gitbook.io/understanding-the-uefi-secure-boot-chain/
\subsubsection{Secure Boot}
% https://edk2-docs.gitbook.io/understanding-the-uefi-secure-boot-chain/secure_boot_chain_in_uefi/uefi_secure_boot
\subsubsection{Signed Capsule Update}
SMM
\subsubsection{TPM}
SEC starts by measuring PEI

\section{Windows}
\subsection{User Access Control (UAC)}
\subsection{Signing}
\subsection{Bitlocker}
\subsubsection{TPM}
how does it work
explain TPM