% !TEX root = ../thesis.tex

\chapter{Past Threats}
\label{sec:past-threats}

% https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf
% https://www.researchgate.net/profile/Anton-Sergeev-2/publication/269310822_Too_young_to_be_secure_Analysis_of_UEFI_threats_and_vulnerabilities/links/551306b50cf23203199aa237/Too-young-to-be-secure-Analysis-of-UEFI-threats-and-vulnerabilities.pdf

Before we implement our own \ac{UEFI} attacks, we first take a look at how past \ac{UEFI} threats are structured.
The threats discussed range from actual attacks found in the wild and analyzed by security researchers, over attacks that have been implemented for similar research purposes, to tools that enable system owners a more advanced control over their systems.


\begin{center}
    \begin{tabular}{lll}
        \toprule
        \textbf{Approach}                  & \textbf{Bootkit} & \textbf{Rootkit} \\
        \arrayrulecolor{gray}
        \cmidrule[0.4pt](r){1-1}
        \cmidrule[0.4pt](lr){2-2}
        \cmidrule[0.4pt](l){3-3}
        \multirow{4}{4em}{Storage\-/based} & \textbf{ours}    & VectorEDK        \\
                                           &                  & Mosaicregressor  \\
                                           &                  & LoJax            \\
                                           &                  & \textbf{ours}    \\
        \cmidrule[0.4pt](r){1-1}
        \cmidrule[0.4pt](lr){2-2}
        \cmidrule[0.4pt](l){3-3}
        \multirow{3}{4em}{Memory\-/based}  & Efiguard         & MoonBounce       \\
                                           & ESPecter         & CosmicStrand     \\
                                           & Dreamboot        &                  \\
                                           & FinSpy           &                  \\
        \arrayrulecolor{black}
        \bottomrule
    \end{tabular}
\end{center}

\section{Infection}

The infection is the most important part of an attack, as it dictates when, in what environment, and with what privileges the \ac{UEFI} payload is executed.

\subsection{Bootkit}

Bootkits use the \ac{UEFI} Boot manager to gain execution on a system.
There are a variety of methods using different options of the boot mechanism.
FinSpy backs up and replaces the Windows Boot Manager \program{bootmgfw.efi} on the \ac{ESP} \cite{finspy}.
ESPecter patches the entrypoint of the Windows Boot Manager \program{bootmgfw.efi} and its copy \program{bootx64.efi} in the default boot path, so that it executes malicious code upon launch \cite{especter}.
Dreamboot and EFIGuard are more proof-of-concept than real attacks and suggest to be booted into using removable media, but they are also able to be added to the default boot path on an \ac{ESP}, or generally added as their own new boot entry \cite{efiguard}.
They are both applications which launch the Windows Boot Manager through its boot entry upon execution \cite{dreamboot, efiguard}.

\subsection{Rootkit}

Firmware rootkits have been rarer and how exactly the firmware images were infected is not often known.
VectorEDK uses \ac{OEM}'s software tooling to generate a firmware update utility on a bootable \ac{USB} stick that can then be inserted with physical access to the system \cite{mosaicregressor}.

\TODO{hier weitermachen}

RWEverything legitimate driver for hardware information
        reading and writing memory mapped \ac{I/O} and \ac{PCI} Configuration registers
        to find spi flash mapping and read from it
        remove previous NTFS driver
        add DXE drivers
        reflash image
        \ac{BIOS} control register with \ac{BIOS} write enable bit and \ac{BIOS} lock enable bit
        the locking mechanism has to be implemented by firmware designers through \ac{SMM} interrupts
        \ac{BIOS} write enable bit is initially written but the interrupt resets it to 0
        when not correctly implemented this does not happen
        and on old platforms a race condition with multi\-/core and multi\-/threadding
        where one thread sets the write bit enable to 1 and the other tries to write to the \ac{SPI} flash
        \cite{lojax}

The payload itself were usually \ac{DXE} drivers residing in a firmware volume \cite{mosaicregressor-technical-details,lojax}, as these are automatically executed by the \ac{DXE} dispatcher.
MoonBounce and CosmicStrand do something different and instead patch existing files in the firmware image.
MoonBounce patches the \ac{DXE} Core \cite{moonbounce}, while CosmicStrand patches an existing \ac{DXE} driver \cite{cosmicstrand}.
While both approaches could fundamentally be done in the form of an added \ac{DXE} driver, it makes the detection harder.

\section{Approach}

We can categorize the threats by their attack vector.
Rootkits and bootkits do not seem to have distinct approaches, as they both start their execution in the \ac{UEFI} environment prior to the Windows boot process.
We found that their approach can mainly be divided into storage\-/based and memory\-/based attacks.
Storage\-/based attacks mostly gain execution in the operating system environment by writing their payload into the Windows installation and modifying configuration data on the disk.
These attacks are often performed offline, before any parts of the operating system are executed.
Memory\-/based attacks instead hook into the operating system's boot process to execute malicious code alongside the operating system in memory.
For storage\-/based attacks, we were only able to find examples of rootkits \cite{vector-edk,mosaicregressor-technical-details,lojax}, whereas memory\-/based attacks were performed by both root- and bootkits \cite{dreamboot,efiguard,especter,finspy,moonbounce,cosmicstrand}.
There is no technical limitation as we show in \autoref{sec:attacks:neither:bootkit} when we implement our own storage\-/based bootkit, but more likely a general preference for memory\-/based attacks, as they are more sophisticated.
Storage\-/based attacks face more restrictions such as BitLocker and code integrity checks.

\subsection{Storage-based}

Storage\-/based attacks need file-based access to the Windows installation to modify its content.
The primary partition is \ac{NTFS} formatted and, due to the \ac{UEFI} specification only mandating compliant firmware to support \ac{FAT}12, \ac{FAT}16 and \ac{FAT}32 \cite[Section 13.3.1.1]{uefi-spec}, \ac{NTFS} drivers are delivered as part of the attack.
\cite{mosaicregressor-technical-details} and \cite{lojax} seem to use \cite{vector-edk}'s leaked \ac{NTFS} driver.
\cite{lojax} deploys its payload under the file path \program{C:\textbackslash Windows\textbackslash SysWOW64\textbackslash autoche.exe} and then modifies the registry entry \program{HKEY\_LOCAL\_MACHINE\textbackslash SYSTEM\textbackslash CurrentControlSet\textbackslash Control\textbackslash Session Manager\textbackslash BootExecute}, so that their payload is executed instead of the original executable.
\cite{mosaicregressor-technical-details} simply deploys their payload in the Windows startup folder, whose contents, as its names suggests, are executed upon Windows startup.

\subsection{Memory-based}

It seems to be unique to \cite{especter} to patch out the integrity self-check of the Windows Boot Manager, as it is the only bootkit to change the bootloader on disk instead of in-memory.
\cite{finspy, dreamboot} when executed, load \program{bootmgfw.efi} into memory and apply patches before launching it.
\cite{efiguard}'s core functionality is the same for its root- and bootkit variant.
A \ac{DXE} driver is loaded, either from the \ac{DXE} dispatcher or through an intermediary loader application.
This driver then hooks the \ac{UEFI} boot service \code{LoadImage()}. When this is either called by the \ac{UEFI} boot manager or the loader application to load \program{bootmgfw.efi}, it patches the bootloader in memory \cite{efiguard}. \cite{moonbounce} applies its patches within an \code{ExitBootServices()} hook.

The general approach is the same for all memory\-/based attacks.
They propagate their malicious execution further up in the boot chain, by hooking when images are loaded, i.e., from \program{bootmgfw.efi} to \program{Winload.efi} to \program{ntoskernel.exe} to the kernel image.

Some attacks patch the kernel to disable Windows Driver signing and then install a kernel driver \cite{efiguard,especter}.
Others deploy payloads with elevated privileges \cite{finspy, dreamboot} or map code directly into the kernel space \cite{moonbounce,cosmicstrand}.