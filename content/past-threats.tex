% !TEX root = ../thesis.tex

\chapter{Past Threats}
\label{sec:past-threats}

% https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf
% https://www.researchgate.net/profile/Anton-Sergeev-2/publication/269310822_Too_young_to_be_secure_Analysis_of_UEFI_threats_and_vulnerabilities/links/551306b50cf23203199aa237/Too-young-to-be-secure-Analysis-of-UEFI-threats-and-vulnerabilities.pdf

Before we implement our own \ac{UEFI} attacks, we first take a look at how past \ac{UEFI} threats are structured.
The threats discussed range from actual attacks found in the wild and analyzed by security researchers, over attacks that have been implemented for similar research purposes, to tools that enable system owners a more advanced control over their systems.


\begin{center}
    \begin{tabular}{lll}
        \toprule
        \textbf{Approach}                  & \textbf{Bootkit} & \textbf{Rootkit} \\
        \arrayrulecolor{gray}
        \cmidrule[0.4pt](r){1-1}
        \cmidrule[0.4pt](lr){2-2}
        \cmidrule[0.4pt](l){3-3}
        \multirow{4}{4em}{Storage\-/based} & \textbf{ours}    & VectorEDK        \\
                                           &                  & Mosaicregressor  \\
                                           &                  & LoJax            \\
                                           &                  & \textbf{ours}    \\
        \cmidrule[0.4pt](r){1-1}
        \cmidrule[0.4pt](lr){2-2}
        \cmidrule[0.4pt](l){3-3}
        \multirow{3}{4em}{Memory\-/based}  & Efiguard         & MoonBounce       \\
                                           & ESPecter         & CosmicStrand     \\
                                           & Dreamboot        &                  \\
                                           & FinSpy           &                  \\
        \arrayrulecolor{black}
        \bottomrule
    \end{tabular}
\end{center}

\section{Infection}
\vspace{-0.5em}

The infection is the most important part of an attack, as it dictates when, in what environment, and with what privileges the \ac{UEFI} payload is executed.

\vspace{-0.5em}
\subsection{Bootkit}
\vspace{-0.5em}

Bootkits use the \ac{UEFI} Boot manager to gain execution on a system.
There are a variety of methods using different mechanisms of the boot process.
FinSpy backs up and replaces the Windows Boot Manager \program{bootmgfw.efi} on the \ac{ESP} \cite{finspy}.
ESPecter patches the entry point of the Windows Boot Manager \program{bootmgfw.efi} and its copy \program{bootx64.efi} in the default boot path, so it executes malicious code upon launch \cite{especter}.
Dreamboot and EFIGuard are more proof-of-concept than real attacks and suggest being booted into using removable media, but they are also able to be added to the default boot path on an \ac{ESP}, or generally added as their own new boot entry \cite{efiguard}.
They are both applications, which launch the Windows Boot Manager through its boot entry upon execution \cite{dreamboot, efiguard}.

\subsection{Rootkit}

Firmware rootkits have been rarer and how exactly the firmware images were infected is not often known.
VectorEDK uses \ac{OEM}'s software tooling to generate a firmware update utility on a bootable \ac{USB} stick that can then be inserted with physical access to the system \cite{mosaicregressor}.

LoJax infection method comes with the signed kernel driver from the program \program{RWEverything}.
\program{RWEverything} is a legitimate tool that can be used to query hardware\-/related information on a system.
LoJax uses the driver to read and write to memory mapped \ac{I/O}, as well as \ac{PCI} configuration registers.
It leverages this to find the \ac{SPI} flash mapping, to dump the firmware image.
It then removes previously packaged \ac{NTFS} drivers and adds its payload.
Reflashing the modified image relies on the platform to be either misconfigured or of an older kind that has a race condition exploit.
The \ac{SPI} flash is secure by a \ac{BIOS} control register, which has a \ac{BIOS} Write Enable bit and \ac{BIOS} Lock Enable bit.
The locking mechanism has to be correctly implemented by firmware designers through \ac{SMM} interrupts.
When writing to the \ac{BIOS} Write Enable bit, while the \ac{BIOS} is enabled, the operation initially succeeds but is then reverted by a \ac{SMM} interrupt routine.
This could either be incorrectly implemented or exploited through race conditions using multi\-/processing or multi\-/threading existing on older hardware.
When one thread constantly sets the Write Enable bit to 1 and the other tries to perform write operations on the \ac{SPI} flash, the firmware image will eventually be overwritten \cite{lojax}.

MosaicRegressor and LoJax add their payload in the form of \ac{DXE} drivers to a firmware volume \cite{mosaicregressor-technical-details,lojax}, as these are automatically executed by the \ac{DXE} dispatcher.
MoonBounce and CosmicStrand instead patch existing files in the firmware image.
MoonBounce patches the \ac{DXE} Core \cite{moonbounce}, while CosmicStrand patches an existing \ac{DXE} driver \cite{cosmicstrand}.
While both approaches could fundamentally be done in the form of an added \ac{DXE} driver, it does make the detection harder.

\section{Approach}

We can categorize the threats by their attack vector.
Rootkits and bootkits do not seem to have distinct approaches, as they both start their execution in the \ac{UEFI} environment prior to the Windows boot process.
We found that their approach can mainly be divided into storage\-/based and memory\-/based attacks.
Storage\-/based attacks mostly gain execution in the operating system environment by writing their payload into the Windows installation and modifying configuration data on the disk.
These attacks are often performed offline before any parts of the operating system are executed.
Memory\-/based attacks instead hook into the operating system's boot process to execute malicious code alongside the operating system in memory.
For storage\-/based attacks, we were only able to find examples of rootkits \cite{vector-edk,mosaicregressor-technical-details,lojax}, whereas memory\-/based attacks were performed by both root- and bootkits \cite{dreamboot,efiguard,especter,finspy,moonbounce,cosmicstrand}.
There is no technical limitation as we show in \autoref{sec:attacks:neither:bootkit} when we implement our own storage\-/based bootkit, but more likely a general preference for memory\-/based attacks, as they are more sophisticated.
Storage\-/based attacks face more restrictions such as BitLocker and code integrity checks.

\subsection{Storage-based}

Storage\-/based attacks need file\-/based access to the Windows installation to modify its content.
The primary partition is \ac{NTFS} formatted and, due to the \ac{UEFI} specification only mandating compliant firmware to support \ac{FAT}12, \ac{FAT}16 and \ac{FAT}32 \cite[Section 13.3.1.1]{uefi-spec}, \ac{NTFS} drivers are delivered as part of the attack.
MosaicRegressor and Lojax seem to use VectorEDK's leaked \ac{NTFS} driver \cite{mosaicregressor-technical-details, lojax}.
LoJax deploys its payload under the file path \program{C:\textbackslash Windows\textbackslash SysWOW64\textbackslash autoche.exe} and then modifies the registry entry \program{HKEY\_LOCAL\_MACHINE\textbackslash SYSTEM\textbackslash CurrentControlSet\textbackslash Control\textbackslash Session Manager\textbackslash BootExecute}, so that their payload is executed instead of the original executable \cite{lojax}.
MosaicRegressor simply deploys its payload in the Windows startup folder \cite{mosaicregressor-technical-details}, whose contents, as its name suggests, are executed upon Windows startup.

\subsection{Memory-based}

It seems to be unique to ESPecter to patch out the integrity self-check of the Windows Boot Manager, as it is the only bootkit to change the bootloader on disk instead of in\-/memory \cite{especter}.
FinSpy and Dreamboot when executed, load \program{bootmgfw.efi} into memory and apply patches before transferring execution \cite{finspy, dreamboot}.
EFIGuard loads an additional \ac{UEFI} driver which is able to hook the boot service \code{LoadImage()}.
When the function is called to load \program{bootmgfw.efi}, it patches the bootloader in memory \cite{efiguard}.
MoonBounce applies its patches from within an \code{ExitBootServices()} hook \cite{moonbounce}.

The general approach is the same for all memory\-/based attacks.
They propagate malicious code execution further up in the boot chain by hooking each image of the boot process as it is loaded into memory, i.e., from \program{bootmgfw.efi} to \program{Winload.efi} to \program{ntoskernel.exe}, the kernel image.

EFIGuard and ESPecter patch the kernel to disable Windows Driver signing, allowing them to install further kernel drivers \cite{efiguard,especter}.
While FinSpy and Dreamboot deploy payloads executed with elevated privileges \cite{finspy,dreamboot}.
MoonBounce and CosmicStrand map code directly into the kernel space \cite{moonbounce,cosmicstrand}.