% !TEX root = ../thesis.tex

\chapter{Attacks}

We split our attacks into three different categories facing escalating levels of security mechanisms. All attacks share the assumption of being able to add DXE Drivers to the DXE Volume. This can be achieved by having read/write access to the SPI flash or using the Signed Capsule Update. Gaining read/write access to the SPI Flash is possible either through physical access to the device by using an SPI clamp on the chip itself or through exploits like for example the
% see SMM multi threaded exploit
. Signed Capsule Updates can be leveraged with access to private vendor information by signing the payload to make it appear legitimate or by intercepting the distribution process and employing infected firmware.
% ref lenovo vantage for distributed example
% network boot maybe




\section{Neither Secure Boot nor Bitlocker}
use read access to dump image
% ref to background UEFI/PI IMAGE
since it an FV with FFS we can open with UEFITool
remove previous NTFS driver if present, for full control, might be read only etc
in UEFITool search and remove
add in NTFS driver
use write access

try in EFI shell
navigate to Windows folder
create folder

how does one compile uefi application with edk2
it's open source so we can look up examples for most stuff

try in code
compile dxe driver within ovmf to receive .ffs file with version depex user interface section
SimpleFileSystem Protocol iteration
write failed on hibernated file
patch to allow write on hibernated drives

pack executable binary as uefi module
iterate over firmware volume protocols
search for payload guid
check size match
override notepad works

% ref to background UAC signed
but no automatic execution nor elevated privileges
dll proxying
dll hijacking
registry editing

Task Scheduler
defined in xml
cached in registry
edit with start cmd.exe and trigger manually
whoami

chntpw and reged
port to uefi
edit Task in machine under Control
maybe look if just adding a key would have also worked
export target registry key
modify so that registry key can differ and found via matching values
import and override registry key on target machine
payload whoami
localsystem


\section{Secure Boot}
how does one enable it
mostly comes with default keys OEM
expectation:
not to boot
observation:
no difference
% ref to paper default policy
secure boot default policy snippet
option roms and bootloader
% ref background firmware update
instead relies on Signed Capsule Updates
assumes integrity


\section{Secure Boot and Bitlocker}
assumptions:
secure boot or not
bitlocker enabled with TPM auto decryption

observation:
boot execution differs from executing rootkit
tpm values different
bitlocker auto decryption fails
recovery key prompt

what is the reaction of the average user
(ask admin for recovery password)
type in recovery password
alternative would be to remove drive and insert into safe device

% ref to background os loader
prompt is done by the OS Loader
ergo still during transient system load phase
required to use protocol services
therefor uses uefi services for IO
such as SimpleTextInputEx Protocol
go over the two different input protocols
find out which one is used

explain more in depth how protocols are returned to the end user
one instance per controller/handle

explain basic hooking
explain how we retain information of the hook in question
map protocol pointer to hook information
keylog recovery key
key input advancment is weird and makes tracking tricky

alternatively screen shot
still need hook to find when enter is pressed
explain how screenshotting works
some basic compression
wait for recovery key
send recovery key on enter press

on real hardware
network stack wasn't installed onto handles when boot over ip was disabled
compared loaded dxe drivers between both configurations with efi shell
Realtek Family driver not loaded
load manually
reinstall all handle to controllers to enable network stack regardless

sending key out is only good for physical access attack vector
dislocker linux utility
mount encrypted drive with decryption mean
read and write access
dual boot in vm
enter password and it works
port to uefi
bitlocker encrypts block-wise
uefi protocol stack
hook block io
again hook data mapping
dislocker validate block
solves recovery key advancement issue

hook ExitBootServices
enable hook
write payload
import registry key
disable hook

next boot would require to input tpm values again
update tpm values in payload
caveat pin? look into this

% reference to rootkit definition
persistence when part of root of trust
fresh install / tpm update values
% paper von betreuern
hook Trusted Copmuting Group 2 (TCG2) Protocol
TPM communication
receive bitlocker vmk key and send to dislocker